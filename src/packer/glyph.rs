use super::{
    packer2d::{Packer, Rect},
    TexturePosition,
};
use fontdue::Font;
use glam::Vec2;
use glium::{
    backend::Facade,
    texture::{
        MipmapsOption, RawImage2d, Texture2dDataSink, TextureCreationError, UncompressedFloatFormat,
    },
    uniforms::Sampler,
    Texture2d,
};
use std::{borrow::Cow, collections::HashMap};

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
struct Glyph {
    index: u16,
    scale: u16,
}

pub struct Glyphs {
    texture: Texture2d,
    packer: Packer,
    font: Font,

    contained: HashMap<Glyph, (u8, TexturePosition)>,

    queue: Vec<Glyph>,
}

impl Glyphs {
    pub fn new<F: Facade>(
        facade: &F,
        font: Font,
        rect: Rect,
    ) -> Result<Self, TextureCreationError> {
        let texture = Texture2d::empty_with_format(
            facade,
            UncompressedFloatFormat::F32,
            MipmapsOption::AutoGeneratedMipmaps,
            rect.width,
            rect.height,
        )?;
        let packer = Packer::new(rect);

        let contained = HashMap::new();

        let queue = Vec::new();

        Ok(Self {
            texture,
            packer,
            font,

            contained,

            queue,
        })
    }

    pub fn queue(&mut self, c: char, scale: u16) {
        self.queue.push(Glyph {
            index: self.font.lookup_glyph_index(c),
            scale,
        });
    }

    pub fn flush(&mut self) {
        let mut tmp_queue = vec![];
        std::mem::swap(&mut tmp_queue, &mut self.queue);

        for queued in tmp_queue.drain(..) {
            if self.get_glyph(&queued).is_some() {
                continue;
            }

            let (metrics, data) = self
                .font
                .rasterize_indexed(queued.index, queued.scale as f32);

            let rect = self
                .packer
                .push(Rect::new(metrics.width as u32, metrics.height as u32))
                .unwrap(); // TODO:

            let data = RawImage2d::from_raw(Cow::from(&data[..]), rect.width, rect.height);

            self.texture.write(
                glium::Rect {
                    left: rect.x,
                    bottom: rect.y,
                    width: rect.width,
                    height: rect.height,
                },
                data,
            );

            self.contained.insert(
                queued,
                (
                    0,
                    TexturePosition {
                        top_left: Vec2::new(
                            (rect.x as f64 / self.texture.dimensions().0 as f64) as f32,
                            (rect.y as f64 / self.texture.dimensions().1 as f64) as f32,
                        ),
                        bottom_right: Vec2::new(
                            ((rect.x + rect.width) as f64 / self.texture.dimensions().0 as f64)
                                as f32,
                            ((rect.y + rect.height) as f64 / self.texture.dimensions().1 as f64)
                                as f32,
                        ),
                    },
                ),
            );
        }
    }

    fn get_glyph(&self, glyph: &Glyph) -> Option<TexturePosition> {
        Some(self.contained.get(glyph)?.1)
    }

    pub fn get(&self, c: char, scale: u16) -> Option<TexturePosition> {
        self.get_glyph(&Glyph {
            index: self.font.lookup_glyph_index(c),
            scale,
        })
    }

    pub fn get_indexed(&self, index: u16, scale: u16) -> Option<TexturePosition> {
        self.get_glyph(&Glyph { index, scale })
    }

    pub fn sampled(&self) -> Sampler<'_, Texture2d> {
        self.texture.sampled()
    }

    pub fn font(&self) -> &'_ Font {
        &self.font
    }
}
